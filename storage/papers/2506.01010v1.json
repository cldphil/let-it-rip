{
  "id": "http://arxiv.org/abs/2506.01010v1",
  "title": "Efficient Model Checking for the Alternating-Time μ-Calculus via\n  Effectivity Frames",
  "summary": "The semantics of alternating-time temporal logic (ATL) and the more\nexpressive alternating-time {\\mu}-calculus (AMC) is standardly given in terms\nof concurrent game frames (CGF). The information required to interpret AMC\nformulas is equivalently represented in terms of effectivity frames in the\nsense of Pauly; in many cases, this representation is more compact than the\ncorresponding CGF, and in principle allows for faster evaluation of coalitional\nmodalities. In the present work, we investigate whether implementing a model\nchecker based on effectivity frames leads to better performance in practice. We\nimplement the translation from concurrent game frames to effectivity frames and\nanalyse performance gains in model checking based on corresponding\ninstantiations of a generic model checker for coalgebraic {\\mu}-calculi, using\ndedicated benchmark series as well as random systems and formulas. In the\nprocess, we also compare performance to the state-of-the-art ATL model\ncheckerMCMAS. Our results indicate that on large systems, the overhead involved\nin converting a CGF to an effectivity frame is often outweighed by the benefits\nin subsequent model checking.",
  "authors": [
    "Daniel Hausmann",
    "Merlin Humml",
    "Simon Prucker",
    "Lutz Schröder"
  ],
  "published": "2025-06-01T13:43:17Z",
  "updated": "2025-06-01T13:43:17Z",
  "categories": [
    "cs.LO"
  ],
  "pdf_url": "http://arxiv.org/pdf/2506.01010v1",
  "full_text": "--- Page 1 ---\narXiv:2506.01010v1  [cs.LO]  1 Jun 2025\nV\n1\n.\n1\nA\nr\nt\ni\nf\na\nc\nt\ns\nA\nv\na\ni\nl\na\nb\nl\ne\nR\ne\nu\ns\na\nb\nl\ne\nV\n1\n.\n1\nA\nr\nt\ni\nf\na\nc\nt\ns\nE\nv\na\nl\nu\na\nt\ne\ndEfficient Model Checking\nfor the Alternating-Time µ-Calculus\nvia Effectivity Frames\nDaniel Hausmann1⋆, Merlin Humml2⋆⋆, Simon Prucker2⋆ ⋆ ⋆, and Lutz\nSchröder2†\n1University of Liverpool, United Kingdom\n2Friedrich-Alexander-Universität Erlangen-Nürnberg, Germany\nAbstract. The semantics of alternating-time temporal logic (ATL) and\nthe more expressive alternating-time µ-calculus (AMC) is standardly\ngiven in terms of concurrent game frames (CGF). The information re-\nquired to interpret AMC formulas is equivalently represented in terms of\neffectivityframesinthesenseofPauly;inmanycases,thisrepresentation\nis more compact than the corresponding CGF, and in principle allows for\nfaster evaluation of coalitional modalities. In the present work, we inves-\ntigate whether implementing a model checker based on effectivity frames\nleads to better performance in practice. We implement the translation\nfrom concurrent game frames to effectivity frames and analyse perfor-\nmance gains in model checking based on corresponding instantiations of\na generic model checker for coalgebraic µ-calculi, using dedicated bench-\nmark series as well as random systems and formulas. In the process,\nwe also compare performance to the state-of-the-art ATL model checker\nMCMAS. Our results indicate that on large systems, the overhead in-\nvolved in converting a CGF to an effectivity frame is often outweighed\nby the benefits in subsequent model checking.\nKeywords: Model checking ·multi-agent systems ·alternating-time\ntemporal logic ·concurrent game frames\n1 Introduction\nAlternating-time temporal logic (ATL) and its extension with full fixpoints, the\nalternating-time µ-calculus (AMC) play an established role as a core formalism\nfor the specification of multi-agent systems [2]. They allow expressing the ability\nof groups of agents ( coalitions ) to achieve short-term and long-term goals by\n⋆Supported by the ERC Consolidator grant D-SynMA (No. 772459) and by the EP-\nSRC through grant EP/Z003121/1\n⋆⋆Funded by the German Federal Chamber of Notaries, project DIREGA\n⋆ ⋆ ⋆Funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Founda-\ntion) – project number 517924115\n†Funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Founda-\ntion) – project number 419850228\n--- Page 2 ---\n2 D. Hausmann, M. Humml, S. Prucker, L. Schröder\ncoordinated action. The semantics of ATL and the AMC is standardly defined\nin terms of concurrent game frames (CGFs), which at each state assign to each\nagent an explicit set of available moves, along with an outcome function deter-\nmining which successor state is reached once all agents have picked a move. It\nhas been shown that for purposes of evaluating AMC formulas, one may equiv-\nalently convert a CGF into an effectivity frame , which at each state records,\nfor each coalition C, a set of sets of states, understood as consisting of those\nstate properties that Cmay (alternatively) enforce by joint action in the next\nstate [20].\nLike in the case of standard temporal logics, one of the key verification tasks\nin this context is model checking , i.e. to determine whether a given state in a\nmulti-agentsystem,sayaCGF,satisfiesagivenformulaofATLortheAMC.The\nmostnaturalwaytopresenttheinputsystemforpurposesofATLorAMCmodel\nchecking is, presumably, indeed to specify a CGF, which makes the actions avail-\nable to the agents and their effects explicit. On the other hand, it is immediate\nfrom inspection of the respective semantics that evaluation of alternating-time\nmodalities, which over CGFs amounts to the evaluation of nested quantifiers\nover actions (“coalition Chas a joint action such that no matter what the other\nagents do, the target formula holds”) and hence takes exponential time in the\nnumber of agents, is computationally more efficient on effectivity frames, where\nit reduces to a simple look-up operation.\nIn the present work, we explore whether this observation can be translated\ninto actual efficiency gains in model checking. That is, we trade the computa-\ntional cost of evaluating coalitional modalities on CGFs for an additional pre-\nprocessing step in which we translate a CGF into an effectivity frame. The\ncomputations involved in the translation are, prima facie, similar to the ones in-\nvolved in evaluating coalitional modalities on CGFs, but they are performed only\nonce, while especially in the AMC, modalities may be evaluated repeatedly at\nthe same state. We provide an implementation of AMC model checking both on\nCGFs and on effectivity frames, building on a generic implementation of model\ncheckingalgorithmsforcoalgebraic µ-calculi[11]withinthe Coalgebraic Ontology\nLogic Solver (COOL) [8,9,10]. Thereby, we incidentally provide, as far as we are\naware, the first model checker that covers the entire AMC (which contains ATL∗\nas a fragment [2, Theorem 6.1]), rather than only ATL; furthermore, our tool is\nagnostic as to whether the input multi-agent system is provided in the form of a\nCGF or as an effectivity frame and hence enables working directly with effectiv-\nity frames. We run extensive experiments both on random models and formulas\nand on dedicated benchmark series; besides comparing between CGF-based and\neffectivity-frame-based model checking, we also compare the performance of our\nimplementation with the state-of-the-art ATL model checker MCMAS [17]. As\nexpected, results vary strongly with the exact nature of benchmark series, in\nparticular in the comparison with MCMAS; notably, MCMAS implements sym-\nbolic model checking while COOL offers only explicit-state model checking, and\ncorrespondingly MCMAS performs better on problems that can be succinctly\n--- Page 3 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 3\nrepresented symbolically while COOL plays out advantages when this is not the\ncase.\nRelated Work As indicated above, the notion of effectivity frame semantics was\nintroduced by Pauly [20]. Goranko and Jamroga [6] provide a comparison of\nATL semantics over CGFs, effectivity frames, and alternating transition systems\n(ATSs), in which the moves of the agents are subsets of the state space. The\ntranslation from CGFs to ATSs involves a blowup of the state space, so we\nrefrain from including ATS semantics in the present comparison. As far as we\nare aware, the first implemented model checker for ATL was MOCHA [1], which\nhowever seems to be no longer available. Kański et al. [13] compare MCMAS to\nan ATL model checker UMC4ATL based on McMillan’s method of unbounded\nmodel checking [18]. The results indicate better performance of MCMAS, on\nwhichwethereforefocusinourcomparativeevaluation.Thecomplexityofmodel\nchecking ATL and related logics has been investigated extensively already at\nthe time of introduction [2]; we additionally mention work on symbolic model\nchecking for ATL [12] and on the complexity of explicit-state model checking\nfor ATL+[7]. The AMC (hence also ATL*) is subsumed by the more expressive\nstrategy logic (SL) [5], which allows the specification of strategies that fail to be\nω-regular, but has nonelementary model checking [19]; restricted fragments of\nSL with more favourable model checking complexities have been considered [4,3]\n(and implemented in MCMAS-SLK [4]).\n2 The Alternating-Time µ-Calculus\nWe briefly recall the syntax and semantics of the alternating-time µ-calculus, a\nfixpoint logic that allows the specification of ω-regular joint strategies of coali-\ntions in multi-agent systems [2]. Its key feature are coalitional modalities [C]\n‘coalition Cof agents is able to enforce’; temporal idioms over this base are\nexpressed using least and greatest fixpoint operators. The alternating-time µ-\ncalculus contains alternating-time temporal logic (ATL) as a fragment, embed-\nded in essentially the same way as computational tree logic embeds into the\nstandard µ-calculus.\nSyntaxFormulas of the alternating-time temporal µ-calculus (AMC) are given\nby the following grammar, depending on (countable) sets Ag,AtandVofagents,\npropositional atoms andfixpoint variables , respectively.\nφ, ψ ::=⊤ | ⊥ | p| ¬p|φ∧ψ|φ∨ψ|[C]φ| ⟨C⟩φ|X|ηX. φ\nwhere p∈At,X∈V,η∈ {µ, ν}, and Cranges over coalitions , i.e. subsets of\nAg.Coalitional modalities [C]φ(for which we employ notation as in coalition\nlogic[20]) intuitively express that the agents in coalition Chave a joint strategy\nto enforce φin the next step of the game; dually, ⟨C⟩φexpresses that coalition C\ncannot prevent that φis satisfied in the next step. The fixpoint operators give\nrise to standard notions of boundandfree(occurrences of) fixpoint variables;\n--- Page 4 ---\n4 D. Hausmann, M. Humml, S. Prucker, L. Schröder\na formula is closedif it does not contain free fixpoint variables, and cleanif\nevery fixpoint variable in it is bound by at most one fixpoint operator. Given\na closed formula φ, we let |φ|denote its syntactic size. The algorithms and\nimplementations in this paper work on the closure cl(φ)ofφ. The closure is a\nsuccinctgraphrepresentationoftherespectiveformula,intuitivelyobtainedfrom\nits syntax tree by identifying occurrences of fixpoint variables with their binding\nfixpoint operators; we have |cl(φ)| ≤ |φ|. Finally, we define the alternation-depth\nad(φ)of fixpoint formulas φ=ηX. ψin the usual way, capturing the number of\nalternations between least and greatest fixpoints; for a detailed account of these\nsyntactic notions, see [15].\nAs mentioned in Section 1, the AMC has various equivalent semantics; we\nrecall the semantics based on concurrent game frames [2] and that based on\neffectivity frames [20]. Let Wbe a non-empty finite set of states. A model M=\n(F, ρ)consists of a valuation ρ:At→ P (W)that assigns to each propositional\natom a∈Atthe set ρ(a)of states that satisfy a;Fis either a concurrent game\nframe (over W) or an effectivity frame (over W), introduced next.\nConcurrent game frame semantics: For a coalition C, we write ΠC=N|C|to\ndenote the set of joint (one-step) strategies (orjoint moves ) ofC; we denote\nthe set ΠAgofcomplete (one-step) strategies (orgrand moves ) by just Π. Given\na joint strategy sC∈ΠCofC, any joint strategy sC∈ΠCof the counter\ncoalition C=Ag\\Cinduces a complete strategy (sC, sC)∈Π. In this notation,\naconcurrent game frame (CGF)\nF= (W, m :W×Ag→N, f:W×Π ⇀ W )\nconsists of Wtogether with functions\n–m:W×Ag→N, assigning to each state w∈Wand each agent a∈Agthe\nnumber m(w, a)>0of moves available to agent aat the state w; and\n–f:W×Π ⇀ W, assigning to each state w∈Wand each complete strategy\ns= (s1, . . . , s |Ag|)∈Πthatisadmissible atw,i.e.si< m(w, i)forall i∈Ag,\nanoutcome state f(w, s)∈W.\nSatisfaction w, σ|=φof an AMC formula φin a state wof a CGF F= (W, m, f )\nis defined inductively, depending on a valuation σ:V→ P (W)of the fixpoint\nvariables; we denote the extension ofφunder σbyJφKσ={w∈W|w, σ|=φ}.\nFor a coalition Cand a state w∈W, we let Πw\nCdenote the set of joint strategies\nofCthat are admissible at w. The semantic clauses for propositional atoms\nand connectives are as usual (the former is given by the valuation ρof atoms);\nmodalities are interpreted as\nJ[C]φKσ={w∈W| ∃sC∈Πw\nC.∀sC∈Πw\nC. f(w,(sC, sC))∈JφKσ}\nJ⟨C⟩φKσ={w∈W| ∀sC∈Πw\nC.∃sC∈Πw\nC. f(w,(sC, sC))∈JφKσ}\n(where we write (sC, sC)for the complete strategy extending sCandsC) so that,\ne.g.,w, σ|= [C]φif and only if coalition Chas a joint strategy sCatwsuch\n--- Page 5 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 5\nthat for all strategies that complete sCand are admissible at w, the outcome\nsatisfies φunder the valuation σof fixpoint variables; and the semantics of\nfixpoint operators is given (exploiting the Knaster-Tarski fixpoint theorem) by\nJµX. φ Kσ=T{Z⊆W|JφKX\nσ(Z)⊆Z}JνX. φ Kσ=S{Z⊆W|Z⊆JφKX\nσ(Z)},\nwhere JφKX\nσis the function defined by JφKX\nσ(A) = JφKσ[X7→A]forA⊆W, where\nσ[X7→A](X) =Aandσ[X7→A](Y) =σ(Y)forY̸=X. For aclosedformula φ\n(in which all fixpoint variables Xoccur in the scope of some binding fixpoint\noperator µXorνX),JφKσdoes not depend on σ, so in this case we just write\nJφK(or JφKFto make the semantic domain explicit) for JφKσ.\nEffectivity frame semantics: Aneffectivity frame (EF)\nF= (W, e:W× P(Ag)→ P (P(W)))\nconsists of Wtogether with an effectivity function ethat assigns, to each state\nw∈Wand each coalition C⊆Ag, a set e(w, C)of sets of states. Intuitively, we\nwill have U∈e(w, C)whenever coalition Chas a joint strategy sCatwthat\nguarantees that the next state in the game is contained in U. To support this\nintuitive meaning, effectivity frames need to be restricted to be playable, ensur-\ning for finite Wthat they are induced by a CGF [20,6,16]. When constructing\neffectivity frames from CGFs, playability is automatic.\nSatisfaction of AMC formulas over an effectivity frame F= (W, e)is defined\ninductively by the same clauses for propositional and fixpoint operators as for\nCGFs, but modalities are interpreted as\nJ[C]φKσ={w∈W| ∃U∈e(w, C). U⊆JφKσ}\nJ⟨C⟩φKσ={w∈W| ∀U∈e(w, C). U∩JφKσ̸=∅}\nso that with this semantics, w, σ|= [C]φif and only if coalition Ccan enforce\nsome set Uat state wsuch that all states contained in Usatisfy φ(under\nthe valuation σof fixpoint variables). The difference between the two semantics\nis displayed in Fig. 1, which illustrates the encoding of a single game step in\nboth representations. In the CGF encoding on the left hand side, we have, e.g.,\nw1|= [{1,3}]qsince, for the joint strategy that agents 1and3both pick their\nsecond move, the outcome is always w3, no matter which move agent 2picks.\nThis is reflected in the EF encoding by {1,3}being able to force the singleton\nset{w3}.\nConcurrent game frames can be transformed into equivalent effectivity\nframes [20]; explicitly, the conversion works as follows.\nDefinition 1 (Induced effectivity frame). A CGF F= (W, m, f )induces\nthe effectivity frame F′= (W, e)defined by\ne(w, C) ={{f(w, sC, sC)|sC∈Πw\nC} |sC∈Πw\nC}\nforw∈WandC⊆Ag.\n--- Page 6 ---\n6 D. Hausmann, M. Humml, S. Prucker, L. Schröder\nw1w2p w3q\n(1,2,1),(2,2,1),\n(2,1,1),(1,1,1),\n(1,1,2)(1,2,2),(2,2,2),\n(2,1,2)\nw1w2p w3q\n{1},{2},\n{3}{1,2},{3} {2,3},{1,3}\nFig. 1.Concurrent game frame semantics vs. effectivity frame semantics\nLemma 2. LetFbe a concurrent game frame and let F′be the effectivity frame\ninduced by F, and let σbe a valuation. Then for all formulas φ,\nJφKF,σ=JφKF′,σ.\nProof.The claim follows immediately from the equi-satisfaction of modalities\ninFandF′. For readability, we show this for closed modal formulas [C]ψ.\nAssuming that JψKF=JψKF′, we have\nJ[C]ψKF={w∈W| ∃sC∈Πw\nC.∀sC∈Πw\nC. f(w,(sC, sC))∈JψKF}\n={w∈W| ∃sC∈Πw\nC.∀u∈ {f(w, sC, sC)|sC∈Πw\nC}. u∈JψKF′}\n={w∈W| ∃U∈ {{f(w, sC, sC)|sC∈Πw\nC} |sC∈Πw\nC}. U⊆JψKF′}\n={w∈W| ∃U∈e(w, C). U⊆JψKF′}\n=J[C]ψKF′,\nwhere the second equivalence holds by assumption. ⊓ ⊔\n3 Model Checking for the AMC\nThe model checking problem for the AMC consists in deciding, for state win\na model given either as a CGF or as an effectivity frame, and a closed AMC\nformula φ, whether w∈JφK. The problem is known to be in NP∩co-NPfor\nthe AMC, and in PTimefor ATL. A standard way to decide the problem is\nby reduction to parity games, enabling the use of recent quasipolynomial game-\nsolving algorithms for model checking in the AMC.\nParity Games: Aparity game G= (V, V∃, E, Ω )is an infinite-duration two-\nplayer game, played by the players ∃and∀(EloiseandAbelard). It consists of\na set Vof positions, with positions V∃⊆Vowned by ∃and the others by ∀,\namoverelation E⊆V×V, and a priority function Ω:V→N. Aplayis\na path in the directed graph (V, E)that is either infinite or ends in a node\nv∈Vwith no outgoing moves. Finite plays v0v1. . . v nare won by ∃if and\n--- Page 7 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 7\nonly if vn∈V∀(i.e. if ∀is stuck); infinite plays are won by ∃if and only if\nmax{p| ∀j∈N.∃k≥j. Ω(vk) =p}is even. A (history-free) ∃-strategy is a\npartial function s:V∃⇀ Vthat assigns moves to ∃-nodes. A play followsa\nstrategy sif for all i≥0such that vi∈V∃,vi+1=s(vi). An∃-strategy winsa\nnode v∈Vif∃wins all plays that start at vand follow s.\nWe fix a closed formula φfor the remainder of this section and let cl=cl(φ)\ndenote its (Fischer-Ladner) closure[14].\nDefinition 3 (Modelcheckinggames,CGFsemantics). Givenamodel M\nconsistingofaconcurrentgameframe F= (W, m, f )andavaluation ρ,themodel\nchecking game GCGF\nM,φ= (V, E, Ω )is the parity game defined by the following\ntable, where game nodes v∈V=V∃∪V∀are of the shape v= (w, ψ)∈W×cl\norv= (w, ψ, s C)∈W×cl×ΠC; in the latter case, we require ψto be a modality.\nnode owner moves to priority\n(w,⊤) ∀ ∅ 0\n(w,⊥) ∃ ∅ 0\n(w, p) ∃ {(w, p)|w∈ρ(p)} 0\n(w,¬p) ∀ {(w,¬p)|w∈ρ(p)} 1\n(w, φ∧ψ)∀ {(w, φ),(w, ψ)} 0\n(w, φ∨ψ)∃ {(w, φ),(w, ψ)} 0\n(w, ηX. ψ )∃ {(w, ψ[ηX. ψ/X ])} ad(ηX. ψ )\n(w,[C]ψ)∃ {(w,[C]ψ, sC)|sC∈ΠC(w)} 0\n(w,⟨C⟩ψ)∀{(w,⟨C⟩ψ, sC)|sC∈ΠC(w)} 0\n(w,[C]ψ, sC)∀{(f(w, sC, sC), ψ)|sC∈ΠC(w)} 0\n(w,⟨C⟩ψ, sC)∃{(f(w, sC, sC), ψ)|sC∈ΠC(w)} 0\nThusGCGF\nM,φis a parity game with at most |W| × |cl| ×(|Π|+ 1)nodes and at\nmost ad(φ)priorities. We point out that the model checking game has winning\n(resp. losing) self loops at nodes (w, p)(resp. (w,¬p)) such that w∈ρ(p).\nLemma 4. LetFbe a concurrent game frame with set Wof states, and let\nw∈Wbe a state. Then we have w∈JφKFif and only if the existential player\nwins the node (w, φ)inGCGF\nM,φ.\nDefinition 5 (Model checking games, EF semantics). If the model Mis\ngiven as an effectivity frame F= (W, e), the model checking game GEF\nM,φ= (V=\nV∃∪V∀, E, Ω )is defined in the same way as for concurrent game frames, but with\nnodes v= (w, ψ, U )∈W×cl×P(W)replacing the nodes (w, ψ, s )∈W×cl×Π\n(with ψof the form [C]ψ′or⟨C⟩ψ′). The modal moves are given by the table\nbelow; all other moves, and also node ownership and the priority assignments,\nare as in the CGF model checking game given above.\nnode owner moves to priority\n(w,[C]ψ)∃{(w,[C]ψ, U)|U∈e(w, C)} 0\n(w,⟨C⟩ψ)∀{(w,⟨C⟩ψ, U)|U∈e(w, C)} 0\n(w,[C]ψ, U)∀ {(v, ψ)|v∈U} 0\n(w,⟨C⟩ψ, U)∃ {(v, ψ)|v∈U} 0\n--- Page 8 ---\n8 D. Hausmann, M. Humml, S. Prucker, L. Schröder\nIn this case, GEF\nM,φis a parity game with at most |W| × |cl| ×(2|W|+ 1)nodes\nand at most ad(φ)priorities.\nCorollary 6. LetFbe an effectivity frame with set Wof states, and let w∈W\nbe a state. Then we have w∈JφKFif and only if the existential player wins the\nnode (w, φ)inGEF\nM,φ.\nWe point out that the above reductions to parity games make all transitions\nin models explicit, leading to games with a relatively large number of game\nnodes. Next, we present an alternative solution method that directly evaluates\n(sub)formulas over the state space W. This method does not explicitly construct\nthe model checking games, and thereby avoids the blowup in state space incurred\nby the reduction to parity games.\nDefinition 7 (One-step evaluation). Given sets V⊆WandX=\nX0, . . . , X k⊆V×cl, we define a monotone function propV:P(V×\ncl)k+1→ P (V×cl)evaluating propositional operators over argument sets\nX= (X0, . . . , X k)by\npropV(X) =V× {⊤} ∪ { (w, p)|w∈ρ(p)} ∪ { (w,¬p)|w /∈ρ(p)}∪\n{(w, φ∧ψ)| {(w, φ),(w, ψ)} ⊆X0}∪\n{(w, φ∨ψ)| {(w, φ),(w, ψ)} ∩X0̸=∅}∪\n{(w, ηX. ψ )|(w, ψ[ηX. ψ/X ])∈Xad(ηX. ψ )}\nBuilding on this, we define functions fcgf\nV:P(V×cl)k+1→ P (V×cl)and\nfef\nV:P(V×cl)k+1→ P (V×cl)that evaluate formulas step by step using CGF\nsemantics and EF semantics, respectively; formally, we put\nfCGF\nV(X) =propV(X)∪ {(w,[C]ψ)| ∃sC∈Πw\nC.∀sC∈Πw\nC.(f(w, sC, sC), ψ)∈X0}\n∪ {(w,⟨C⟩ψ)| ∀sC∈Πw\nC.∃sC∈Πw\nC.(f(w, sC, sC), ψ)∈X0}\nfEF\nV(X) =propV(X)∪ {(w,[C]ψ)| ∃U∈e(w, C).(U× {ψ})⊆X0}∪\n{(w,⟨C⟩ψ)| ∀U∈e(w, C).(U× {ψ})∩X0̸=∅}\nDefinition 8. Given V⊆Wand a monotone function f:P(V×cl)k+1→\nP(V)×cl, we define the nested fixpoints\nEf=ηkXk. ηk−1Xk−1. . . . . νX 0.f(X0, . . . , X k)\nAf=ηkXk.ηk−1Xk−1. . . . . µX 0.f(X0, . . . , X k)\nwhere ηi=νfor even iandηi=µfor odd i; also, ν=µandµ=ν. We use f\nto denote the dual function to f. These functions evaluate parity objectives over\nthe functions fandf, intuitively solving the associated model checking game\nbyinlining intermediate game nodes that arise from the necessity to evaluate\nmodalities; crucially, the domain of these fixpoint computations is P(V)×cl\nrather than the full set of nodes from the model checking game.\n--- Page 9 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 9\nLemma 9 ([11]). LetFbe a CGF with set Wof states, and let w∈Wbe a\nstate. Then w∈JφKFif and only if (w, φ)∈EfCGF\nW; ifFinstead is an effectivity\nframe, then we have w∈JφKFif and only if (w, φ)∈EfEF\nW.\nTheaboveimpliesamodelcheckingalgorithmthatcomputesthenestedfixpoints\ninDefinition8iteratively.Thisalgorithmcanbeextendedtosupport localmodel\nchecking, i.e. may avoid exploring the entire model if satisfaction of the target\nformula in a target state can be determined early [11].\n4 Implementation\n4.1 COOL - The Coalgebraic Ontology Logic Solver\nThe model checking implementation is set within the framework provided by\nCOOL / COOL 2 / COOL-MC - the COalgebraic Ontology Logic solver - a\ncoalgebraic reasoner and model checker for modal fixpoint logics [8,9,10], imple-\nmented in OCaml. We contribute implementations of the translation from CGFs\nto effectivity frames and instantiations of the generic tool to both CGFs and\neffectivity frames. In the COOL model checking framework, models are repre-\nsented as functions f:W→FWwhere Fis a set constructor obtained from\nthe grammar\nF, G ::=M|id| PF|F×G|M→G\nwhere Mranges over sets. The application FXof a set constructor to a set X\nis defined as follows: MX =M,idX=X,PFX =P(FX),(F×G)X=\nFX×GX,(M→G)X=M→GX, where P(FX)is the power set of FXand\nM→GXis the set of functions with domain Mand codomain GX. Functions\nof type W→FWare referred to as F-coalgebras [23] but we refrain from\ndelving into the general theory. Effectivity frames are then F-coalgebras for\nF=PAt×(P(Ag)→ PP ), while concurrent game frames are F-coalgebras for\nF=PAt×NAg×(Π→id).\nAs the datatype to represent all types of models, COOL defines the algebraic\ndatatype functor_element .\n4.2 Parity Game Model Checking\nIn COOL-MC, the generation of parity games is implemented as a higher order\nfunction that traverses the input model and formula and translates all connec-\ntives into game nodes as described in Section 3, implementing the interpretation\nof modal operators using a function it receives as an argument. Each occurrence\nof a coalitional modality generates a region consisting of inner nodes; the re-\nmaining nodes are called outer nodes, and form a further region. The structure\nof inner nodes differs depending on the semantics. Each region has an initial\nnode (either the occurrence of a modality or the root node of the game). The\ntype for game nodes consists of one algebraic type encoding the structure of\n--- Page 10 ---\n10 D. Hausmann, M. Humml, S. Prucker, L. Schröder\ninner nodes, and a further algebraic type encoding whether a node is an inner\nnode or not.\nThe parity game thus created then can be solved using any parity game\nsolver; COOL-MC, which we employ for the experiments in this work, uses the\nimplementation of Zielonka’s algorithm that is provided by PGSolver [24].\n4.3 Local Model Checking\nWithintheCOOL-MCframework,wealsoimplementthealternativelocalmodel\nchecking algorithm described in Section 3, again realized as a higher order func-\ntion that receives the semantic function for modalities as an argument, as in\nDefinition 7, and then computes the relevant fixpoints by Kleene approxima-\ntion; indeed, both coalitional modalities [C]and⟨C⟩are implemented within\nthe same function. Recall that the semantics of [C]ψis given by\n∃sC∈ΠC(w).∀sC∈ΠC(w).(f(w, sC, sC), ψ)∈X0\nin CGF semantics (using notation introduced in Section 2). The quantifiers in\nthis formula are implemented by traversing all joint moves of CandC, respec-\ntively.\nThe implementation of the semantics of coalitional modalities for local model\nchecking over CGFs (see Listing 1) enumerates all possible moves using the\nrecursive function try_outuntil it either has found a witnessing move for the\ncoalition, or it has proved that there is not such a move. This is achieved by\nadvancing the move of the coalition if the reached world with the curr_move does\nnotsatisfytheargumentformula( xnotcontainedin argset).Thiscorrespondthe\nexistential search for the move of the coalition in the concurrent game structure\nsemantics definition. When the current move of the coalition reaches a satisfying\nworld then instead themove ofthe opposition d_baris advanced using next_move .\nThe recursion stops if the individual moves have hit the move_bounds so that all\nrelevant moves have been explored.\nFor comparison, in EF semantics, the semantics of [C]ψis realized by imple-\nmenting the function\n∃U∈e(w, C).(U× {ψ})⊆X0.\nListing 2 shows the new implementation in COOL. Due to the generic repre-\nsentation of the models and formulas, a few lines of code are needed to extract\nthe coalition and eff_func from the model and formula representation. Then\nthecapabilities of the coalition corresponding to the e(w, C)in the semantics\ndefinition are looked up ( H.find) in the hash table underlying the effectivity\nfunction. The subsequent existssearch then corresponds to picking the set U\nin the semantics, and checking containment of Uinargsetcorresponds to the\nclause U⊆JφKσin the semantics definition.\n--- Page 11 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 11\nlet coalition_modal_pred _ form xi_of_x argset argset_dual =\nlet open Output in\nlet* (box, d) =\nmatch form.HCFml.node with\n| F.HCENFORCES (d, _) -> return (true, d)\n| F.HCALLOWS (d, _) -> return (false, d)\n| _ -> Error (InvalidInput ( \"coalition_modal_pred\"))\nin\nlet argset = if box then argset else argset_dual in\nbegin (* xi_of_x = (moves_1, ..., moves_n, result_fun) *)\nlet* tuple = M.fe_tuple_to_list xi_of_x in\nlet n = ((length tuple) - 1) in (* number of agents *)\n...\nlet rec try_out curr_move =\nlet x = Hashtbl.find result_fun curr_move in\nif mem x argset then\nbegin\nlet next = next_move_for move_bounds d_bar curr_move in\nif next = curr_move then return true else try_out next\nend\nelse\nbegin\nlet next = next_move_for move_bounds d curr_move in\nif next = curr_move\nthen return false\nelse try_out (reset d_bar next)\nend\nin\n(* start exploring with move where everyone chooses 1 *)\ntry_out (List.init n (fun _ -> 1) )\nend ||> fun x -> if box then x else not x\nListing 1: Semantics of the coalitional modalities for local model checking in\nconcurrent game structure semantics\n--- Page 12 ---\n12 D. Hausmann, M. Humml, S. Prucker, L. Schröder\nlet coalition_modal_effectivity_pred _ form xi_of_x argset argset_dual =\nlet open Output in\nlet* (box, coalition) =\nmatch form.HCFml.node with\n| F.HCENFORCES (d, _) -> return (true, d)\n| F.HCALLOWS (d, _) -> return (false, d)\n| _ -> Error (InvalidInput ( \"coalition_modal_effectivity_pred\"))\nin\nlet argset = if box then argset else argset_dual in\nbegin\nlet* eff_func = M.fe_function_to_htbl __LINE__ xi_of_x in\nlet capabilities = H.find eff_func (Set (map M.int coalition)) in\n...\nreturn (exists (fun succs -> subset succs argset) capabilities)\nend ||> fun x -> if box then x else not x\nListing 2: Semantics of the coalitional modalities for local model checking in\neffectivity frame semantics\n4.4 Converting CGFs to EFs\nTo calculate the induced effectivity function at a given state in a CGF,\nwe implement the translation procedure described in Definition 1. As the\nset of states stays the same, the overall conversion is just a matter of\nconverting the structure at each state individually. We define a function\neffectivity_function_of_game_form , which we iterate over all states to compute\nthe resulting effectivity function (see Listing 3). As the effectivity function as-\nsigns an effectivity set to every coalition, the implementation creates an empty\nhash table and then iterates over the set all_coalitions and calls the internal\nfunction enforced_sets_for_coalition to calculate the effectivity. This is done\nby calculating all admissible joint moves of the given coalition. Then the set\nall_moves is read off from the domain of result_func and filtered for each of\nthe partial moves of the coalition to get all grand moves extending the partial\nmove of the coalition. Mapping the result_func over the resulting set gives the\nset of states reached by the joint move. After the effectivity functions have been\ncomputed, our conversion procedure filters the effectivity functions to only con-\ntain minimal sets. This operation ensures minimal runtime and space usage in\nall further processing of the resulting effectivity frames.\n5 Experiments\nWe conduct various experiments, evaluating the performance of the different\nimplementations of model checking for the alternating-time µ-calculus in com-\nparison with each other, and (on the ATL fragment) in comparison to the state-\nof-the-art ATL model checker MCMAS. In more detail, we run benchmarks on\nthe following implementations.\n--- Page 13 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 13\nlet effectivity_function_of_game_form game_form =\nmatch game_form with\n| Tuple (* (moves_1, ..., moves_n, result_func)*) ->\n...\nlet effectivity = H.create (number_of_agents) in\n...\nlet move_is_extension grand_move coal coal_move =\nfor_all2 (fun x y -> (nth grand_move (x-1)) = y) coal coal_move\nin\nlet result_states coal coal_move = (* reached with partial move *)\nlet result_state_for_extension grand_move =\nif move_is_extension grand_move coal coal_move\nthen Some (result_func grand_move) else None\nin\nSet (filter_map result_state_for_extension all_moves)\nin\nlet moves_for_coalition coal =\nlet actions_for_coal = map (fun x -> (*{1,...,moves_x}*) ) coal in\nall_combinations actions_for_coal\nin\nlet enforced_sets_for_coalition coal =\nSet (map (result_states coal) (moves_for_coalition coal))\nin\niter (fun coal ->\nH.add effectivity coal (enforced_sets_for_coalition coal)\n) all_coalitions; Function effectivity\nListing 3: Conversion from CGFs to effectivity frames\n--- Page 14 ---\n14 D. Hausmann, M. Humml, S. Prucker, L. Schröder\n–Our implementation of concurrent game frame semantics model checking as\nan instance of COOL. We denote these algorithms by CGF g(model checking\nby parity game reduction, using the implementation of Zielonka’s algorithm\nprovided by PGSolver [24] to solve the resulting games) and CGF l(local\nmodel checking), respectively.\n–Our implementation of model checking for effectivity frame semantics as\nan instance of COOL, writing EF g(model checking by parity game reduc-\ntion) and EF l(local model checking), respectively, to denote the pure model\nchecking algorithms; the combined algorithms that first perform the trans-\nformation from CGF to EF and subsequently model check are denoted by\nEFC gand EFC l.\n–Thesymbolicmulti-agentsystemmodelcheckerMCMAS(version1.3.0)[17];\nin contrast to the implementations within COOL, MCMAS handles\nadditional epistemic modalities, and uses ordered binary decision dia-\ngram (OBDD) representations of models and formulas. On the other hand,\nMCMAS does not support the full AMC, so that the comparison between\nour implementations in COOL-MC and MCMAS is restricted to ATL.\nIn benchmarks, we use hyperfine [21] to average the measured values over at\nleast five executions and set a timeout of 200 seconds. All experiments have\nbeen executed on a machine with an AMD Ryzen 7 2700 CPU and 32GB of\nRAM. An artifact containing the source code of our implementations, evaluation\nscripts and benchmarking sets for all experiments described below will be made\navailable.\n5.1 Random Formulas over Random Games\nIn a first experiment, we evaluate our implementations within COOL on ran-\ndom AMC formulas of increasing size on random concurrent game frames, each\nwith 10 states, 4 agents, and either 2 or 10 moves per agent (due to the dif-\nferences in model representation, a meaningful comparison with MCMAS on\nrandom models does not appear feasible).\n5.2 Castle Game\nThecastle game hasbeenusedforbenchmarkinginpreviousworkonATLmodel\nchecking [22,13]. The game is parametrized over the number of castles and the\nhealth points all castles start with. Each castle has a corresponding knight that\ncan, in each turn, either be sent out to attack another castle or stay and defend\nthe castle. In each turn, all knights decide concurrently which other castle they\nwant to attack or if they want to stay at their castle and defend. A knight\nwho has attacked in one turn needs to stay and rest in the next turn. A castle\nthat has its knight defending it or resting can block one attack. Each unblocked\nattack on a castle reduces that castle’s number of health points by one. When\nno health points are left, the castle has lost the game and can no longer attack;\nthis situation is indicated by propositional atoms losta, where ais a knight.\n--- Page 15 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 15\nFor the castle game we check the following AMC formulas (which are express-\nible in ATL) for satisfaction in the initial state. The formula νX.¬losta∧[{a}]X\nexpresses that the knight ahas a strategy ensuring that her castle never gets\ndestroyed. We check this formula for each a∈Ag. Moreover, the formula\nµX.((V\na∈C¬losta)∧(V\na∈Ag\\Closta))∨[C]X\nexpresses that the coalition Chas a joint strategy to ensure that all other castles\nare eventually destroyed while none of the allied castles (belonging to C) are\ndestroyed. We check this formula for one coalition of each size.\nThe castle game has the property that almost none of the joint moves are\nequivalent, i.e. almost all joint moves lead to a different outcome. The specifica-\ntion in MCMAS uses separated local states of the agents. The encoding of the\ncastle game with ncastles and hhealth points in COOL uses (2×H)nas state\nspace where 2 ={t, f}andH={x|0≤x≤h}.\n5.3 Modulo Game\nThe second game we consider is constructed to showcase the benefit of effectivity\nframes in cases with many equivalent joint moves. The modulo game is parame-\nterized over the number of agents, the number nof moves per agent, and a base\nnumber for the modulo calculation, which is also the number of states. Each\nstate is uniquely identified by satisfaction of an atom pithat witnesses that the\ncurrent state corresponds to a sum of i. In each turn, the agents concurrently\nchoose a number between one and n. The game then moves to the state cor-\nresponding to the sum of the played numbers plus the number of the previous\nstate, modulo the base.\nFor the modulo game, we check the following formulas for satisfaction in the\ninitial state (in which the mentioned sum starts at 0). The formula\nφ1:=V\n0≤i<baseµX. p i∨[C]X\nexpresses that the coalition Chas a joint strategy to reach any state eventually;\nthis property can be expressed in ATL. On the other hand, the formula\nφ2:=νX. µY. (X∧(p0∨[C]Y)∧(pbase/2∨[C]Y))\nexpressestheBüchipropertythatcoalition Chasastrategytoensurethatasum\nof0as well as a sum of base/2occur infinitely often. We check both formulas for\none coalition of each size. We use the first formula for comparison with MCMAS.\nThe second formula requires the full AMC and is hence not covered by MCMAS,\nso it is used only for benchmarking the different COOL implementations. We fix\n10 as the base throughout.\nThe (explicit-state) encoding of the modulo game in COOL is straight-\nforward, having ten states and the expected transition function and valuation.\n--- Page 16 ---\n16 D. Hausmann, M. Humml, S. Prucker, L. Schröder\n5.4 Results\nThe results of the experiment on random formulas are summarized in Fig. 2.\nSuperscripts indicate the number of actions available to each of the agents; all\nmodels generated have 10 states. The vertical axis denotes the mean cumulative\nruntime including model conversion time for one run, i.e. an average over 25\ninstances of the model checking problem, each instance averaged over at least 5\nruns. The horizontal axis denotes the size of formulas in terms of the number of\nconnectives.\nAs indicated in the theoretical discussion of the individual model checking\nalgorithms,inferenceusingEFstartswitharuntimeoffsetowedtotheconversion\nfrom CGF models to EF model. At small problem sizes, this overhead makes\nEF-based model checking slower than direct model checking on CGFs; however,\nthe runtime eventually breaks even, with the EF-based algorithm outscaling the\nCGF implementation. In our benchmark parameters, this happens at a formula\nsize near 16 for the local variants, and for much larger formulas for the game\nbased implementations.\n4 8 16 32 64 128 256 5120.010.1110100\nformula sizeruntime (s)\nCGF10\nlEFC10\nlCGF2\nlEFC2\nl\nCGF10\ngEFC10\ngCGF2\ngEFC2\ng\nFig. 2.Model checking random formulasTheconversion times for the mod-\nulo game are shown in Fig. 3. The\neffort required for converting from a\nconcurrent game frame to an effectiv-\nity frame grows with both the num-\nber of states in the model and the\nnumber of moves. The modulo game\nalways has exactly 10 states, and in-\ncreasing the number of moves per\nagent leads to a blowup in the indi-\nvidual transition functions. The tran-\nsition function has an entry for ev-\nery joint move, so its domain has\nsizemoves_per_agent|Ag|, leading to\nthe drastic growth visible in Fig. 3.\nThe figure also shows the expected\nincrease in conversion time when the\nnumberofagentsisincreased.Thebe-\nhaviour for the castles game is similar\nbut scaled up due to the larger state\nspace.\nThe average runtime results for evaluating all described formulas over the\ncastles game models are depicted in Fig. 4; they appear to show that MCMAS\nconsistently outperforms our implementations in COOL. Both tools have similar\nperformance characteristics with respect to increasing the starting health points\naffecting the number of states in the game and also the number of turns neces-\nsary to defeat a castle. The local variants of the COOL model checking perform\nsignificantly worse than the game-based variants on both the CGF and the EF\nsemantics, possibly due to better scaling of Zielonka’s algorithm as provided\n--- Page 17 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 17\n2 4 6 8 100.010.1110100\nnumber of moves per agentruntime (s)\n2agents 4agents\n3agents 5agents\nFig. 3.Modulo game conversion time2 4 6 8 100.1110100\nstarting health pointsruntime (s)\nMCMAS CGFg EFg\nCGFlEFlEFCg\nFig. 4.Castle game runtime (4 castles)\nby PGSolver in comparison with the naive fixpoint approximation implemented\nin COOL. It is also notable here that while the model checking on effectivity\nframes generally performs better – as seen best in Fig. 4 – the cost of conversion\noutweighs this speedup at this model size. If a large number of formulas is to\nbe evaluated on the same model, the cost of conversion is expected to amortize\ndue to the slight speedup and might make this approach faster in the end. One\nreason why effectivity frames do not result in more speedup in the castle game is\npresumably that almost no moves are equivalent, so the resulting EFs are com-\nparatively large. On the other hand, EF-based model checking performs very\n2 4 6 8 100.010.1110100\nnumber of movesruntime (s)\nMCMAS CGFg EFg\nCGFlEFlEFCg\nFig. 5.Modulo game ( φ1, 4 agents)2 4 6 8 100.010.1110100\nnumber of movesruntime (s)\nCGFlEFlEFCg\nCGFg EFg\nFig. 6.Modulo game ( φ2, 4 agents)\nwell when model checking the modulo games against the formula φ1(Fig. 5).\n--- Page 18 ---\n18 D. Hausmann, M. Humml, S. Prucker, L. Schröder\nThe runtime of the EF-based semantics is essentially constant, while the run-\ntime under CGF semantics increases with the number of moves per agent. The\nconstant runtime under EF semantics is as expected, since any coalition has a\nconstant number of non-equivalent joint moves. The effectivity function hence\nscales mainly with the number of agents and only up to a fixed limit w.r.t. the\nnumber of moves per agent or the size of the coalition. The two EF implementa-\ntions in COOL even outperform MCMAS with increasing number of moves and\nagents. Note however, that the conversion time increases sharply with increas-\ning model size (similar to Fig. 3), nivellating to some extent the performance\ngain when the system is not initially specified as effectivity frame. Spikes in\nthe plots appear to be due to symmetry in the model structure. In Fig. 6, the\nfour COOL implementations are compared on the modulo game with the Büchi\nproperty benchmark formula φ2. As expected, the effectivity-frame-based im-\nplementations have roughly constant performance while the concurrent game\nframe implementations slow down drastically with increased number of moves\nper agent.\nThe three benchmarking sets we evaluate all vary different parameters. Gen-\nerally, effectivity frame semantics plays out its advantages when there are many\nequivalent joint moves of a coalition, as showcased by the constant performance\nin the modulo game (e.g. Fig. 5). Compared to model checking random formulas\non concurrent game frames directly, there is a speedup for large input formulas\nas seen in Fig. 2. The BDD-based approach of MCMAS outperforms COOL on\nexamples with few equivalent joint moves (see Fig. 4). On smaller problems, the\nspeedup of the EF semantics is diminished by the initial cost of conversion when\nthe problem is not specified as effectivity frame directly (see Fig. 3). We note\nhoweverthatCOOListheonlymodelcheckerabletohandlethefullAMCwhere\nthe speedup is potentially multiplied due to unfolding of the fixpoints increasing\nthe effective formula size (see Fig. 6).\n6 Conclusions and Future Work\nWe have analysed efficiency gains in model checking for the alternating-time µ-\ncalculus afforded by converting concurrent game frames into effectivity frames\nin a preprocessing step. We have evaluated this method in comparison both\nwith a direct implementation of model checking on concurrent game structures\nwithin the same overall framework and with the state-of-the-art ATL symbolic\nmodel checker MCMAS. Results show favourable performance of the preprocess-\ning method on large systems that do not have succinct symbolic representations.\nAlargepartofthecomputationalcostofourmethodliesinthepreprocessing,\nsofuturedevelopmentwillfocusonoptimizationsoftheconversion.Inparticular,\nsince the conversion is entirely per-state, there is potential for parallelization.\nMoreover, further performance gains might be achievable by converting from\nconcurrent game frames to effectivity functions by-need, that is, only when a\nmodality is actually being evaluated on the state at hand.\n--- Page 19 ---\nEfficient Model Checking for the Alternating-Time µ-Calculus 19\nReferences\n1. Alur, R., de Alfaro, L., Grosu, R., Henzinger, T.A., Kang, M., Kirsch, C.M., Ma-\njumdar, R., Mang, F.Y.C., Wang, B.: JMOCHA: A model checking tool that ex-\nploitsdesignstructure.In:InternationalConferenceonSoftwareEngineering,ICSE\n2001. pp. 835–836. IEEE Computer Society (2001). https://doi.org/10.1109/ICSE.\n2001.919196\n2. Alur, R., Henzinger, T.A., Kupferman, O.: Alternating-time temporal logic. J.\nACM 49, 672–713 (2002). https://doi.org/10.1145/585265.585270\n3. Belardinelli, F., Jamroga, W., Kurpiewski, D., Malvone, V., Murano, A.: Strategy\nlogic with simple goals: Tractable reasoning about strategies. In: International\nJoint Conference on Artificial Intelligence, IJCAI 2019. pp. 88–94 (2019). https:\n//doi.org/10.24963/IJCAI.2019/13\n4. Cermák, P., Lomuscio, A., Mogavero, F., Murano, A.: MCMAS-SLK: A model\nchecker for the verification of strategy logic specifications. In: Computer Aided\nVerification, CAV 2014. LNCS, vol. 8559, pp. 525–532. Springer (2014). https:\n//doi.org/10.1007/978-3-319-08867-9_34\n5. Chatterjee, K., Henzinger, T.A., Piterman, N.: Strategy logic. Information and\nComputation 208(6), 677–693 (2010). https://doi.org/10.1016/j.ic.2009.07.004\n6. Goranko, V., Jamroga, W.: Comparing semantics of logics for multi-agent systems.\nInformation, Interaction and Agency pp. 77–116 (2004). https://doi.org/10.1007/\n1-4020-4094-6_3\n7. Goranko, V., Kuusisto, A., Rönnholm, R.: Game-theoretic semantics for ATL+\nwith applications to model checking. Inf. Comput. 276, 104554 (2021), https://\ndoi.org/10.1016/j.ic.2020.104554\n8. Gorín, D., Pattinson, D., Schröder, L., Widmann, F., Wißmann, T.: COOL - A\ngenericreasonerforcoalgebraichybridlogics(systemdescription).In:International\nJoint Conference on Automated Reasoning, IJCAR 2014. LNCS, vol. 8562, pp.\n396–402. Springer (2014). https://doi.org/10.1007/978-3-319-08587-6_31\n9. Görlitz, O., Hausmann, D., Humml, M., Pattinson, D., Prucker, S., Schröder, L.:\nCOOL 2 – a generic reasoner for modal fixpoint logics (system description). In: Au-\ntomated Deduction, CADE 2023. LNCS, vol. 14132, pp. 234–247. Springer (2023).\nhttps://doi.org/10.1007/978-3-031-38499-8_14\n10. Hausmann, D., Humml, M., Prucker, S., Schröder, L., Strahlberger, A.: Generic\nmodel checking for modal fixpoint logics in COOL-MC. In: Verification, Model\nChecking, and Abstract Interpretation, VMCAI 2024. LNCS, vol. 14499, pp. 171–\n185. Springer (2024). https://doi.org/10.1007/978-3-031-50524-9_8\n11. Hausmann, D., Schröder, L.: Game-based local model checking for the coalgebraic\nµ-calculus. In: Concurrency Theory, CONCUR 2019. LIPIcs, vol. 140, pp. 35:1–\n35:16. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2019). https://doi.org/\n10.4230/LIPIcs.CONCUR.2019.35\n12. van der Hoek, W., Lomuscio, A., Wooldridge, M.J.: On the complexity of practical\nATL model checking. In: Autonomous Agents and Multiagent Systems, AAMAS\n2006. pp. 201–208. ACM (2006), https://doi.org/10.1145/1160633.1160665\n13. Kański, M., Niewiadomski, A., Kacprzak, M., Penczek, W., Nabiałek, W.: Un-\nbounded model checking for ATL. Studia Informatica 25(1–2) (2021). https:\n//doi.org/10.34739/si.2021.25.01\n14. Kozen, D.: Results on the propositional µ-calculus. Theor. Comput. Sci. 27, 333–\n354 (1983). https://doi.org/10.1016/0304-3975(82)90125-6\n--- Page 20 ---\n20 D. Hausmann, M. Humml, S. Prucker, L. Schröder\n15. Kupke, C., Marti, J., Venema, Y.: Size measures and alphabetic equivalence in\ntheµ-calculus. In: Logic in Computer Science, LICS 2022. pp. 18:1–18:13. ACM\n(2022). https://doi.org/10.1145/3531130.3533339\n16. Litak, T., Pattinson, D., Sano, K., Schröder, L.: Model theory and proof theory\nof coalgebraic predicate logic. Log. Methods Comput. Sci. 14(1) (2018). https:\n//doi.org/10.23638/LMCS-14(1:22)2018\n17. Lomuscio, A., Qu, H., Raimondi, F.: MCMAS: an open-source model checker for\nthe verification of multi-agent systems. Int. J. Softw. Tools Technol. Transf. 19(1),\n9–30 (2017). https://doi.org/10.1007/s10009-015-0378-x\n18. McMillan, K.L.: Applying SAT methods in unbounded symbolic model check-\ning. In: Computer Aided Verification, CAV 2002. LNCS, vol. 2404, pp. 250–264.\nSpringer (2002). https://doi.org/10.1007/3-540-45657-0_19\n19. Mogavero,F.,Murano,A.,Perelli,G.,Vardi,M.Y.:Reasoningaboutstrategies:On\nthe model-checking problem. ACM Trans. Comput. Log. 15(4), 34:1–34:47 (2014).\nhttps://doi.org/10.1145/2631917\n20. Pauly, M.: A modal logic for coalitional power in games. J. Log. Comput. 12(1),\n149–166 (2002). https://doi.org/10.1093/logcom/12.1.149\n21. Peter, D.: hyperfine (2023), https://github.com/sharkdp/hyperfine\n22. Pilecki, J., Bednarczyk, M.A., Jamroga, W.: SMC: synthesis of uniform strategies\nand verification of strategic ability for multi-agent systems. J. Log. Comput. 27(7),\n1871–1895 (2017). https://doi.org/10.1093/logcom/exw032\n23. Rutten, J.J.M.M.: Universal coalgebra: a theory of systems. Theor. Comput. Sci.\n249(1), 3–80 (2000). https://doi.org/10.1016/S0304-3975(00)00056-6\n24. tcsprojects: PGSolver. https://github.com/tcsprojects/pgsolver",
  "text_length": 47545
}